// Стохастическая оптимизация функции
// lwml, (c) ltwood

#ifndef _CGA_
#define _CGA_

#include "mdefs.h"
#include "vector.h"
#include "matrix.h"
#include "frand.h"
#include "i_vfunc.h"

/*#lake:stop*/

namespace lwml {

// Стохастическая оптимизация (минимизация) функции многих переменных.
// Реализован аналог генетического алгоритма для случая вещественных переменных.
// Differential Evolution (DE) for Continuous Function Optimization.
// An algorithm by Kenneth Price and Rainer Storn.
// http://www.ICSI.Berkeley.edu/~storn/code.html

// При создании начальной популяции задаются границы изменения координат ее элементов.
// Эти границы не используются при последующей оптимизации, поэтому
// полученное решение может оказаться сколь угодно большим по норме.
// Для решения задач с ограничениями следует задавать штрафную функцию.
// Обычно не требуется добиваться гладкости минимизируемой функции,
// поэтому штрафная функция может быть тривиальной.

// Процесс стохастической оптимизации управляется параметрами
// len (размер популяции), prtr (вероятность мутации) и alpha (сила мутации).
// Для размера популяции len можно рекомендовать значение
// A * dim, где 5 <= A <= 10.
// Для силы мутации alpha разумные значения выбираются из отрезка [0.4, 1.0],
// причем хорошим начальным значением будет 0.5, но при быстром
// вырождении популяции вдали от решения следует увеличить параметр alpha.
// Вероятность мутации prtr изменяется от 0.0 до 1.0, причем начинать следует
// с относительно больших значений (0.9 или даже 1.0), чтобы проверить
// возможность быстрого получения решения случайным поиском.
// Затем следует уменьшать значения параметра вплоть до 0.1 или даже 0.0,
// когда в популяции практически не вносится изменчивости и поиск
// оказывается конвергентным.
// На сходимость сильнее всего влияют размер популяции и сила мутации,
// тогда как вероятность мутации служит для тонкой настройки.

class real_ga : public value {
public:
  // Инициализация стохастического оптимизатора.
  // Передается размерность пространства состояний dim, численность популяции len
  // и необязательное стартовое значение для генератора случайных чисел.
  real_ga( int dim, int len, real alpha = 0.6, real prtr = 0.8, uint seed = 1 );

  // Получение размерности задачи.
  int dim() const { return _dim; }

  // Получение размера популяции.
  int len() const { return _len; }

  // Старт процесса минимизации.
  // Для членов начальной популяции границы изменения
  // всех координат задаются одновременно.
  void start( const i_vfunction& fn, real a, real b );

  // Старт процесса минимизации.
  // Для членов начальной популяции границы изменения
  // задаются отдельно для каждой координаты.
  void start( const i_vfunction& fn, const vector& a, const vector& b );

  // Сделать один шаг (смена поколения) оптимизации.
  // Возвращает достигнутое минимальное значение.
  real step( const i_vfunction& fn );

  // Сделать max_gen шагов (смен поколений) оптимизации.
  // Возвращает достигнутое минимальное значение.
  real steps( const i_vfunction& fn, int max_gen );

  // Получение j-ой компоненты текущего оптимального вектора.
  real get( int j ) const { return get_crnt()(_min_score_idx, j); }

  // Получение текущего оптимального вектора.
  void get( vector& dst ) const { get_crnt().get_str(dst, _min_score_idx); }

  // Получение достигнутого минимального значения.
  real val() const { return _min_score; }

  // Получение числа оштрафованных особей на текущем шаге.
  // При использовании функции steps() возвращается число
  // оштрафовынных на последнем шаге.
  real penalty() const { return _penalty_count; }

  // Получение числа выживших особей.
  real sur() const { return _sur_count; }

  // Получение геометрического размера популяции.
  void diam( vector& ) const;

private:
  int _dim;             // размерность векторов
  int _len;             // размер популяции
  real _alpha;          // сила мутации
  real _prtr;           // вероятность мутации
  frand _rnd;           // источник энтропии
  matrix _pop1, _pop2;  // рабочие популяции
  vector _cost;         // стоимость элементов
  vector _child;        // ребенок-конкурент
  real _min_score;      // текущий минимум
  int _min_score_idx;   // номер оптимального элемента

  bool _state;

  matrix& get_crnt() { return _state ? _pop1 : _pop2; }
  const matrix& get_crnt() const { return _state ? _pop1 : _pop2; }
  matrix& get_next() { return _state ? _pop2 : _pop1; }

  int _penalty_count;   // счетчики штрафов и выживших
  int _sur_count;

  void select3( int k, int& a, int& b, int& c );
  void update_opt();
};

}; // namespace lwml

#endif // _CGA_
