// КИХ фильтры

#ifndef _FIRFILT_
#define _FIRFILT_

#include "lwml/base/defs.h"
#include "lwml/m_types/cmplx.h"
#include "lwml/m_types/vector.h"
#include "lwml/m_base/i_func.h"

/*#lake:stop*/

namespace lwml {

// Фильтр с конечной импульсной характеристикой
// Реализуется как симметричный фильтр
// Длиной фильтра (len) считается число элементов ИХ
// с неотрицательными значениями индекса
// Например, если len=8, то порядок фильтра
// n = 2*(len-1)+1 = 2 * len - 1
// Может быть сконструирован просто по массиву коэффициентов
// В этом случае считается, что в массиве содержатся элементы ИХ
// для неотрицательных значений индекса
// Можно сконструировать фильтр по частотной характеристике,
// указав длину фильтра и параметр, определяющий точность аппроксимации
// частотной характеристики - он должен быть не меньше 4
// При этом ФЧХ фильтра считается нулевой, АЧХ должна быть симметричной
// аргумент функции - нормализованная частота, изменяющаяся от -1/2 до 1/2
// При этом для вычисления импульсной характеристики
// используется метод частотной выборки
// При конструировании классического фильтра указывается тип фильтра,
// длина фильтра (см. пояснение выше) и параметры фильтра
// Параметры - это одна или две частоты среза
// Метод sp() вычисляет АЧХ на заданной частоте
// Метод mag() дает сумму квадратов коэффициентов фильтра
// Метод apply() осуществляет фильтрацию данных
// Исходные данные берутся из массива src, результат помещается в массив dst.
// Эти массивы должны иметь одинаковый размер.
// Параметр tick позволяет включить вывод собщений о прогессе вычислений.

class fir_filter : public value {
public:
  enum filter_type { // Тип фильтра для классических фильтров
    LP_FILTER, // low-pass filter (ФНЧ)
    HP_FILTER, // high-pass filter (ФВЧ)
    BP_FILTER, // band-pass filter (полосовой)
    NT_FILTER  // notch filter (режекторный)
  };

  fir_filter( const vector& );
  fir_filter( const i_function&, int len, int lenmul = 8 );
  fir_filter( filter_type, int len, real f1, real f2 = 0.0 );

  real sp( real );
  real mag();          // мощность фильтра
  void apply( vector& dst, const vector& src, tick_mode tick = tmOFF );

  real operator[]( int j ) const;

private:
  vector _coeff;
};

inline real fir_filter::operator[]( int j ) const {
  test_index(j, _coeff.len());
  return _coeff[j];
}

}; // namespace lwml

#endif // _FIRFILT_
