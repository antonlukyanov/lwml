// Работа со строками
// lwml, (c) ltwood

#ifndef _CSTRNG_
#define _CSTRNG_

#include "lwml/base/defs.h"
#include "lwml/m_base/mdefs.h"
#include "lwml/base/basex.h"
#include "lwml/platforms.h"

/*#lake:stop*/

namespace lwml {

// Исключение при невозможности преобразования

DEF_EX_TYPE_MSG(ex_base, ex_convert, "incorrect number");

// Оптимальные размеры хэш-таблицы.
// Для нескольких наиболее употребительных степеней двойки
// приведены ближайшие простые числа.
// Для числа NNNN (степени двойки) константа HASH_SIZE_NNNN
// равна ближайшему простому числу.

const int HASH_SIZE_32   = 31;
const int HASH_SIZE_64   = 61;
const int HASH_SIZE_128  = 127;
const int HASH_SIZE_256  = 257;
const int HASH_SIZE_512  = 521;
const int HASH_SIZE_1024 = 1031;

const int CSTRNG_STDSZ     = 32;    // стандартный начальный размер строки
const int CSTRNG_STEP      = 32;    // шаг приращения длины строки

//#stop-stylecheck
const char CSTRNG_STD_DELIM[] = ",;";   // стандартный набор разделителей слов
//#start-stylecheck

// Общеупотребительный синоним для типа cstrng.

typedef class cstrng strng;

// Класс, реализующий простую обертку над строками в стиле C.
// Эта обертка реализует размещение строк в памяти и управление
// выделенной памятью в случае выхода строки за ее границы.

class cstrng : public value {
public:
  // Конструктор пустой строки заданной максимальной длины.
  // Задаваемая длина строки sz используется при выделении памяти
  // и служит ограничением сверху на длину строки, при выполнении
  // которого не происходит перераспределение памяти.
  cstrng( int sz = CSTRNG_STDSZ );

  // Конструктор строки со значением, заданным как простая C-строка.
  cstrng( const char* src );

  // Конструктор копирования.
  cstrng( const cstrng& src );

  // Деструктор.
  ~cstrng();

  // Оператор копирования обычной C-строки.
  cstrng& operator=( const char* src )   { return _assign(src, strlen(src)); }

  // Оператор копирования.
  cstrng& operator=( const cstrng& src ) { return (&src==this) ? *this : _assign(src._data, src.len()); }

  // Константный оператор индексирования.
  // Возвращает константную ссылку на символ, стоящий на заданной позиции.
  const char& operator[]( int j ) const  { 
    int len = this->len();
    test_index(j, len+1); // позволяем адресовать завершающий нуль
    return _data[j]; 
  }

  // Константный оператор индексирования без проверки.
  const char& at( int j ) const  { return _data[j]; }

  // Замещение символа.
  cstrng& setchar( int j, char ch ) { 
    int len = this->len();
    test_index(j, len+1); // позволяем адресовать завершающий нуль
    if( j == len && ch != 0 ) // тест на разрушение строки
      fail_assert("destructive assign");
    _data[j] = ch; 
    return *this;
  }

  // Сделать строку пустой.
  void set_zero()                        { *_data = 0; }

  // Проверить является ли строку пустой.
  bool is_empty()                        { return *_data == 0; }

  // Получить длину строки.
  int len() const                        { return strlen(_data); }

  // Получить объем выделенной под строку памяти.
  int size() const                       { return _size; }

  // Получить указатель на буфер со строкой.
  const char* ascstr() const             { return _data; }

  // Добавить к строке символ.
  // Возвращает ссылку на строку.
  cstrng& concat( char ch )              { return _add(ch); }

  // Добавить к строке C-строку.
  // Возвращает ссылку на строку.
  cstrng& concat( const char* src )      { return _add(src, strlen(src)); }

  // Добавить к строке другую строку.
  // Возвращает ссылку на строку.
  cstrng& concat( const cstrng& src )    { return _add(src._data, src.len()); }

  // Найти в строке заданный символ.
  // Возвращает индекс найденного символа в строке
  // или (-1) если символ не найден.
  int search( char ch ) const;

  // Найти в строке заданный символ, начиная поиск с конца строки.
  // Возвращает индекс найденного символа в строке
  // или (-1) если символ не найден.
  int revsearch( char ch ) const;

  // Найти в строке заданную подстроку.
  // Возвращает индекс первого символа найденной подстроки в строке
  // или (-1) если символ не найден.
  int search( const char* str ) const;

  // Вырезать из строки подстроку.
  // Если передать слишком большую длину подстроки, то подстрока будет
  // содержать весь хвост исходной строки начиная с заданной позиции.
  // pos - позиция первого символа вырезаемой подстроки.
  // len - длина вырезаемой подстроки.
  // Возвращает вырезанную подстроку.
  cstrng subs( int pos, int len ) const;

  // Сравнить строку с переданной C-строкой.
  // Дает тот же результат, что и strcmp().
  // Возвращает результат сравнения [см. strcmp()].
  int cmp( const char* src ) const      { return _cmp(src); }

  // Сравнить строку с переданной строкой.
  // Дает тот же результат, что и strcmp().
  // Возвращает результат сравнения [см. strcmp()].
  int cmp( const cstrng& src ) const    { return _cmp(src._data); }

  // Проверка строки на совпадение с переданной C-строкой.
  // Возвращает true если строки совпадают.
  bool is_eq( const char* src ) const    { return _cmp(src) == 0; }

  // Проверка строки на совпадение с переданной строкой.
  // Возвращает true если строки совпадают.
  bool is_eq( const cstrng& src ) const  { return _cmp(src._data) == 0; }

  // Интерпретировать строку как целое число.
  // При неудаче возвращает false.
  bool as_int_ex( int* res ) const       { return str2int_ex(res, _data); }

  // Интерпретировать строку как вещественное число.
  // При неудаче возвращает false.
  bool as_real_ex( real* res ) const     { return str2real_ex(res, _data); }

  // Интерпретировать строку как целое число.
  // При неудаче генерируется исключение.
  // Возвращает число, полученное в результате преобразования.
  int as_int() const                     { return str2int(_data); }

  // Интерпретировать строку как вещественное число.
  // При неудаче генерируется исключение.
  // Возвращает число, полученное в результате преобразования.
  real as_real() const                   { return str2real(_data); }

  // Получить для строки значение хэш-функции.
  // Возвращает значение хэш-функции.
  uint get_hash() const                  { return str2hash(_data); }

  // Убрать пробелы из начала строки.
  // Возвращает ссылку на строку.
  cstrng& lstrip();

  // Убрать пробелы из конца строки.
  // Возвращает ссылку на строку.
  cstrng& rstrip();

  // Убрать пробелы из начала и конца строки.
  // Возвращает ссылку на строку.
  cstrng& strip();

  // Убрать ведущие пробелы и кавычки (если они есть).
  // В любом случае убирает пробелы слева и справа.
  cstrng& strip_quot( char quot = '"' );  // "

  // Перевести в нижний регистр в заданной codepage (см. alphabet.h)
  cstrng& tolower( int cp ); 

  // Перевести в верхний регистр.
  cstrng& toupper( int cp );

  // Получить первое слово строки и удалить его из строки.
  // По умолчанию разделителями являются запятая и "точка с запятой" (semicolon).
  // delim - задает набор символов-разделителей слов.
  // Возвращает выделенное слово.
  cstrng get_word( const char* delim = CSTRNG_STD_DELIM );

  // Статические низкоуровневые функции преобразования C-строк в числа.

  // Преобразовать C-строку в целое число.
  // При неудаче возвращает false.
  static bool str2int_ex( int* res, const char* str );

  // Преобразовать C-строку в вещественное число.
  // При неудаче возвращает false.
  static bool str2real_ex( real* res, const char* str );

  // Преобразовать C-строку в целое число.
  // При неудаче генерируется исключение.
  // Возвращает число, полученное в результате преобразования.
  static int  str2int( const char* str );

  // Преобразовать C-строку в вещественное число.
  // При неудаче генерируется исключение.
  // Возвращает число, полученное в результате преобразования.
  static real str2real( const char* str );

  // Получить значение хэш-функции для C-строки.
  // Возвращает значение хэш-функции.
  static uint str2hash( const char *str );

  // Статические низкоуровневые функции преобразования чисел в строки.

  // Преобразовать целое число в его строковое представление.
  // Возвращает строковое представление числа.
  static cstrng int2str( int x );

  // Преобразовать беззнаковое целое число в его строковое представление.
  // Возвращает строковое представление числа.
  static cstrng uint2str( uint x );

  // Преобразовать беззнаковое целое число в его шестнадцатеричное представление.
  // Возвращает строковое представление числа.
  static cstrng hex2str( uint x );

  // Преобразовать вещественное число в его строковое представление.
  // prec - точность представления
  // nf - используемая форма записи чисел
  // Возвращает строковое представление числа.
  static cstrng real2str( double x, int prec = 6, real_format nf = nfSCNT );

  // Преобразовать время в секундах в его строковое представление.
  // Строковое представление имеет вид 'hh:mm:ss'.
  // sec - число секунд
  // Возвращает строковое представление времени.
  static cstrng time2str( float sec );

  // Конструирование строки по строке формата.
  // Использование этой функции аналогично функциям printf() и vprintf().
  // Функция автоматически размещает буфер необходимой длины.
  // Возвращает сконструированную строку.
  static cstrng vform( const char *fmt, va_list va );
  static cstrng form( const char *fmt, ... ) PRINTF(1,2);

private:
  // в _size хранится максимальный размер строки, помещающейся в буфер
  // т.е. фактически длина буфера _data всегда равна _size+1
  char* _data;
  int _size;

  void alloc( int );
  void realloc( int );
  void dealloc();

  cstrng& _assign( const char*, int );

  cstrng& _add( const char*, int );
  cstrng& _add( char );

  int _cmp( const char* ) const;

  void _shl( int pos );
};

}; // namespace lwml

#endif // _CSTRNG_
