// Простое битовое множество.
// lwml, (c) ltwood

#ifndef _BITSET_
#define _BITSET_

#include "lwml/base/defs.h"
#include "lwml/types/t_membuf.h"
#include "lwml/io/stream.h"

/*#lake:stop*/

namespace lwml {

// Множество реализуется как строка битов, упакованных в последовательные байты.
// Множество допускает импорт и экспорт данных в виде строки байтов.
// Состояние отдельных битов соответствует присутствию элементов в множестве.
// Порядок битов задается последовательностью их сканирования:
// байты сканируются последовательно с первого, а биты в них
// последовательно, начиная с младшего.
// Длина строки байтов должна соответствовать числу элементов множества.
// При импорте и экспорте для определения длины строки байтов следует
// использовать функцию char_num().

class bitset : public value {
public:
  // Создать битовое множество размером size бит, установив каждый элемент в v.
  bitset( int size, bool v = false );

  // Импортировать значение множества из строки байтов.
  void char_read( const char* buf );

  // Экспортировать значение множества в строку байтов.
  void char_write( char* buf ) const;

  // Возвращает число байтов в представляющей множестве строке байтов.
  int char_num() const { return _data.len(); }

  // Получить число битов в множестве.
  int len() const { return _size; }

  // Сбросить все биты множества в ноль.
  void set_zero();

  // Установить все биты множества в единицу.
  void set_one();

  // Установить бит с номером bit.
  void set( int bit );

  // Сбросить бит с номером bit.
  void clear( int bit );

  // Инвертировать бит с номером bit.
  void flip( int bit );

  // Получить значение бита с номером bit.
  bool test( int bit ) const;

  // Получить максимальное значение бита со значением 1.
  int get_max();

  // Получить минимальное значение бита со значением 1.
  int get_min();

  // Проверить множества на пересечение.
  // Возвращает true если множество пересекается с множеством ls.
  bool is_meet( const bitset& ls ) const;

  // Вычисление объединения множеств.
  // Добавляет множество-аргумент к текущему множеству т.е.
  // устанавливает в множестве все биты, установленные в множестве ls.
  // Возвращает ссылку на измененное исходное множество.
  bitset& join( const bitset& ls );

  // Вычисление пересечения множеств.
  // Пересекает текущее множество с множеством-аргументом т.е.
  // оставляет установленными только биты, установленные в множестве ls.
  // Возвращает ссылку на измененное исходное множество.
  bitset& meet( const bitset& ls );

  // Вычисление симметрической разности множеств.
  // В результат входят все элементы двух множеств,
  // не входящие одновременно в оба множества (побитовый XOR).
  // Возвращает ссылку на измененное исходное множество.
  bitset& symm_dif( const bitset& ls );

  // Возвращает true, если все биты находятся в состоянии false.
  bool is_empty() const;

  void print() {
    for( int i = 0; i < _size; i++ ){
      printf("%d", test(i) ? 1 : 0);
    }
    printf("\n");
  }

private:
  int _size;
  t_membuf<uchar> _data;
};

}; // namespace lwml

#endif // _BITSET_
